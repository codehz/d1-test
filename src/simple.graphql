# define entity, we will generate Query for you
type books @entity {
  id: Int! @column(primary_key: true, alias_rowid: true)
  title: String! @column
  url: String @column
  created_at: String! @column(default: "STRFTIME('%Y-%m-%d %H:%M:%f', 'NOW')")
}

# example for many-to-many relations
type book_author_maps @entity(without_rowid: true) {
  book_id: Int! @column(primary_key: true)
  author_id: Int! @column(primary_key: true)
}

type authors @entity {
  id: Int! @column(primary_key: true, alias_rowid: true)
  name: String! @column
  created_at: String! @column(default: "STRFTIME('%Y-%m-%d %H:%M:%f', 'NOW')")
}

# define relation though type level directive (because it may contain non-trivial parameters)
extend type books
  @relation(
    name: "authors"
    target: "book_author_maps"
    defintions: { from: "id", to: "book_id" }
  )

extend type book_author_maps
  @relation(
    type: object
    name: "author"
    target: "authors"
    defintions: { from: "author_id", to: "id" }
  )
extend type book_author_maps
  @relation(
    type: object
    name: "book"
    target: "books"
    defintions: { from: "book_id", to: "id" }
  )

# You can also define foreign key constraints
extend type book_author_maps
  @foreign_key(from: "book_id", table: "books", to: "id")
extend type book_author_maps
  @foreign_key(from: "author_id", table: "authors", to: "id")

extend type authors
  @relation(
    name: "books"
    target: "book_author_maps"
    defintions: { from: "id", to: "author_id" }
  )
